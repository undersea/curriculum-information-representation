#+TITLE:     Programme Planner
#+AUTHOR:    James Hurford
#+EMAIL:     
#+DATE:      2011-03-30 Wed
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:

#+DRAWERS: HIDDEN

#+STARTUP: hidestars

* Paper Planner                                                    :noexport:
** The Problem
*** How to represent it to users
*** Ideas on the user interface
**** Multi story floor plan
     The building represents the programme.  Years are represented by levels in a building. Each level contains rooms representing papers.  Stairs from rooms can indicate a links between one paper and another at different levels.  Stairs can go up or down.
**** Atom view               
     Each atom is a programme.  The nucleus is the programme name, with each electron being a paper.  Each paper can spin around the nucleus at differing orbits with the lowest one being year 1, going up to year 2, etc.
**** Line graph              
     Lines represent path taken, showing where papers intersect
**** Jigsaw puzzle           
     Puzzle is programme, and pieces are papers, connected to prerequisites and corequisites.
**** Self Organising map     
   + Papers are positioned in the plan in a algorithmic approche using AI and graph theory techniques.
   + Maybe uses idea from jigsaw puzzle and use the connections as limiters
**** Templates
***** A degree is a template via which you can create the programme from
      [[./images/drawing.png]]
**** How to solve it
This was going to be a complete application, but it was realised that
there was not enough time to do everything, so the Use case shown in
figure \ref{fig:usecase1} was adopted, and this would be the scenario that would be
solved using constraints satisfaction.


#+LaTeX: \begin{figure}[H]
#+LaTeX: \centering
#+begin_example
A Student does their first year of study at university.  They pass a
number of papers.  They have not decided upon a major yet, but they
want to know what their options are.  They want to know what major
suits their choice of papers so far the best, and what are the
possible paper combinations they can have for their future programme
of study.  These combinations must be valid for the choice of degree
and major, and allows them to complete their degree if done.  
#+end_example
#+LaTeX: \caption{\label{fig:usecase1} Use case for student having done one year of study}
#+LaTeX: \end{figure}



The first priority was to learn what are Constraints Satisfaction
Problems.  To do this I looked on line and found a definition with a
example, in this case it was the map colours problem.  



What software support there is for Constraints Satisfaction Problems
(CSP) was looked at.  There were criteria under
which the library would be used, in a effort to stay in the language of
choice, python, as much as possible, the library had to be written in
either C/C++ or python.  C/C++ was considered as python can use these
libraries through either the module /ctypes/ or in the form of a
specially written C module, using Python C API.  If it was written
as a C module for python, that could lead to it only being usable by a
Python interpreter written in C.  The choice was to make the
environment used as configurable as possible, so cytpes was chosen, as
in theory, any Python interpreter, no matter what language they are
written in has a /ctypes/ implementation, as /ctypes/ has become part of
the set of standard modules since (citation needed here).


Gecode was looked at and was the choice for implementing the
CSP, as it is a mature library, with one of the
authors claiming that it is relatively bug free.  Also there seemed to
be quiet a few references to Gecode in the forms that were looked at.
Thus there should be plenty of examples on how to solve various
problems using Gecode.

So To use this library there needs to be some research done on how to
use it.  There is a provided manual called "Modeling and Programming
with Gecode" (MPG) \cite{MPG1}.  The approach was to read as much of
this manual MPG as is needed to implement the solution come up with to
solve the problem.


While reading this document, some of the examples were gone through to
figure out how Gecode encodes CSP.


In Figure \ref{fig:GecodeArch} The Gecode Model Archatechture you have
3 layers, the Model, 

#+ATTR_LaTeX: width=30em,placement=[H]
#+CAPTION: The Gecode Model Archatechture
#+LABEL: fig:GecodeArch
[[./images/gecode-model.png]]

One of the strategies taken was to have a look and see what books
there are on the subject, in regard to the problem.  The books
available are almost non existent, except for one book that was a
collection of articles which sounded like they might be solving a
similar problem was "Planning, Scheduling and Constraint Satisfaction:
to Practice." \cite{COBA01}.  However the problem they were
attempting to solve, were not close enough to the Paper Planner
problem.



** Solutions chosen
The solution come up with, as shown in figure
\ref{fig:decisionprocess}, aims at being simple.  The problem of a
large search space has been addressed by narrowing down the search by
using a simple algorithm of counting the number of papers done that
are in the major schedule for each major available, and the major that
has the academic record has the most papers, is the chosen set that is
used to create a leads to tree.  This tree is then used as the search
space for the constraints satisfaction part.  The rules are based upon
the minimum required papers to satisfy the degree requirements and the
minimum to satisfy the major requirements.  
#+attr_latex: width=30em,placement=[H]
#+CAPTION: The decision process for determining programme selection options
#+LABEL: fig:decisionprocess
#+BEGIN_DITAA decision-process-diagram -r -S -E
               +---------+   +----------+   +----------+   +--------------+
               | Major   |   | Leads to |   | Degree   |   | Valid        |
               | Paper   |   | Paper    |   | Paper    |   | Degree       |
               | List    |   | DB       |   | List     |   | Paper        |
               | {s}c888 |   | {s}c888  |   | {s} c888 |   | Combinations |
               |         |   |          |   |          |   | {s}c888      |
               +----+----+   +----+-----+   +----------+   +--------------+
                    |    |        |         |              |
                    |    +----+   |         |              |
                    |         |   |         |              |
                    V         V   V         V              V
+----------+   +----+-----+   +---+---------+  +-----------+--+
| Student  |   | Select   |   | Create      |  | Determine    |
| Academic |   | Best     |   | Paper       |  | Valid        |
| Record   +-->+ Major    +-->+ Leads to    +->+ Paper        |
| {s}c888  |   | {io}cBLU |   | Tree        |  | Combinations |
|          |   |          |   | {io}cBLU    |  | {io} cBLU    |
+----------+   +----------+   +-------------+  +--------------+
#+END_DITAA
*** Constraints Satisfaction

*** Database use.
*** Programming library choice


*** Programming language choice
** Challenges
*** Using python to run C++ code
Python can import C libraries using /ctypes/ package and run C
functions.  There are a lot of CSP libraries that are written in C or
C++.  This is one method that can be used to use these libraries.
Gecode is a C++ library, and it was seriously looked at how it can be
used by python.

A solution searcher must be written in C++, if Gecode is to be used,
then compiled into a dynamic library which python can then load and
run function from.  The problem with C++ is that it mangles the names
of functions making it unusable by python as the code used to load
this library was written to load C libraries.  This posses the
question of how do you then use this C++ code.  Fortunately there has
been a solution for a long time.  The 'extern "C"' can be used on
blocks of code or functions to tell the C++ compiler not to mangle the
names of the items in this block and thus enabling C code to use it.
Using this one can then write a C function that calls the C++ code
that you want to run.  This in turn is accessible to the C import
library, which is used by pythons /ctypes/ package.


*** How to represent and encode the problem



** Conclusion
Conclusion is here

# check spelling
* Programme Planner


** Introduction
   This report presents a specification of a way to present this data
   to students, and discusses the ways in which it could be designed
   and implemented. Due to time constraints it has not been
   completed.

   Unfortunately this project ran out of time, and was not
   finished. This report will outline what could have been.
:HIDDEN:
   Can constraints satisfaction be used to aid in the planning of a
   students programme of study towards the selection of papers for a
   degree?  This is a aid to the decision process.  It will show what
   choices they have and show what is possible valid paper
   combinations there are.  It will use constraints satisfaction to
   help decide if the selection of papers are valid.

   The proposal is to try and solve this problem using a constraints
   satisfaction.  Also a define what the user interface would look like.

   Unfortunately this project ran out of time, and was not finished.
   This report will outline what could have been.
:END:

** Design
    Take in a list of papers and determine what is the best degree and
    major combination for this selection.  From there determine the
    best set of papers that the student should do to complete their
    degree major combination.  The solution come up with, is shown in
    figure \ref{fig:decisionprocess}.

    The problem of a large search space has been addressed by
    narrowing down the search by using a simple algorithm of counting
    the number of papers done that are in the major schedule for each
    major available.  The major that has the most papers present in
    academic record, is the chosen set that is used to create a leads
    to tree.  This tree is then used as the search space for
    constraints satisfaction.  The rules are based upon the minimum,
    required papers to satisfy, the degree and major requirements.
    #+attr_latex: width=30em,placement=[H]
    #+CAPTION: The process for determining programme selection options
    #+LABEL: fig:decisionprocess
#+BEGIN_DITAA decision-process-diagram -r -S -E
               +---------+   +----------+   +----------+   +--------------+
               | Major   |   | Leads to |   | Degree   |   | Valid        |
               | Paper   |   | Paper    |   | Paper    |   | Degree       |
               | List    |   | DB       |   | List     |   | Paper        |
               | {s}c888 |   | {s}c888  |   | {s} c888 |   | Combinations |
               |         |   |          |   |          |   | {s}c888      |
               +----+----+   +----+-----+   +----------+   +--------------+
                    |    |        |         |              |
                    |    +----+   |         |              |
                    |         |   |         |              |
                    V         V   V         V              V
+----------+   +----+-----+   +---+---------+  +-----------+--+
| Student  |   | Select   |   | Create      |  | Determine    |
| Academic |   | Best     |   | Paper       |  | Valid        |
| Record   +-->+ Major    +-->+ Leads to    +->+ Paper        |
| {s}c888  |   | cFDA {o} |   | Tree        |  | Combinations |
|          |   |          |   | cFF8        |  | {mo} c9FB    |
+----------+   +----------+   +-------------+  +--------------+
#+END_DITAA
** Ideas
   A set of user interface ideas were discussed
#+ATTR_LaTeX: width=10cm,height=5cm,placement=[H]
#+LABEL: fig:building
#+CAPTION: Building with papers as rooms and stairs connecting them to papers that they lead to or are needed prerequisites.
[[file:images/building.pdf]]
** Implementation
   
*** Programming language
    Python was used in the workload application, so it seemed easier
    to continue using Python.
*** Constraints Satisfaction
    We could develop our own constraints satisfaction library or use a
    third party library.  It was considered to time consuming to
    create one ourselves, so a third party library was investigated.
    Python can use libraries written in C/C++ through the
    module /ctypes/, C library files can be loaded, and their
    functions called from within Python.

    Gecode \cite{gecode1}, and or-tools \cite{or-tools1}, developed by
    Google, were investigated.

    Gecode was chosen due to its maturity, and track record.

**** Gecode
     It has won a few challenges in the last few years.

     #+begin_quote
     Gecode won all MiniZinc Challenges so far (in all categories):
     2010, 2009, and 2008.
     -- http://www.gecode.org/
     #+end_quote

     There is also a active on line community, with plenty of example code
     to reference, found in various places on the web.

     It is also written in C++, which can be called on by Python
     through the /ctypes/ library.
     
     It does not need any external dependencies to be used, thus is
     easy to install.
**** or-tools
     Is a set of operations research tools developed at Google, with one of
     the tools being a constraints solver.  It is written in C++ and has a
     Python implementation.  

     It is dependent on other Google libraries, which complicates its
     use for the developer.  It also is very new, and has not much
     support other than in the form of examples.
** Implementation
